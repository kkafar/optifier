use std::convert::TryFrom;

use optifier::Partial;

/// Basic struct used to test the `Partial` derive, merge, and TryFrom impls.
#[derive(Partial, Debug, PartialEq)]
#[optifier::partial_derive(Debug, Clone, PartialEq)]
pub struct Foo {
    a: i32,
    b: Option<String>,
    pub c: Vec<u8>,
}

#[test]
fn partial_struct_is_generated_and_has_expected_field_types() {
    // This test is more about type checking than runtime behavior.
    // If the generated types don't match what we expect, this won't compile.
    let _partial = FooPartial {
        a: Some(1),
        b: Some("hello".to_string()),
        c: Some(vec![1, 2, 3]),
    };
}

#[test]
fn merge_prefers_left_side_when_present() {
    let left = FooPartial {
        a: Some(1),
        b: Some("left".into()),
        c: None,
    };

    let right = FooPartial {
        a: Some(2),
        b: Some("right".into()),
        c: Some(vec![3, 4, 5]),
    };

    let merged = left.merge(right);

    // For each field, left side wins when it is Some
    assert_eq!(merged.a, Some(1));
    assert_eq!(merged.b.as_deref(), Some("left"));
    // For c, left was None, so value comes from right
    assert_eq!(merged.c, Some(vec![3, 4, 5]));
}

#[test]
fn merge_works_when_both_sides_are_none() {
    let left = FooPartial {
        a: None,
        b: None,
        c: None,
    };

    let right = FooPartial {
        a: None,
        b: None,
        c: None,
    };

    let merged = left.merge(right);

    assert_eq!(merged.a, None);
    assert_eq!(merged.b, None);
    assert_eq!(merged.c, None);
}

#[test]
fn try_from_partial_succeeds_when_all_required_fields_present() {
    let partial = FooPartial {
        a: Some(10),
        b: Some("hello".into()),
        c: Some(vec![1, 2, 3]),
    };

    let foo = Foo::try_from(partial).expect("conversion should succeed");

    assert_eq!(
        foo,
        Foo {
            a: 10,
            b: Some("hello".into()),
            c: vec![1, 2, 3],
        }
    );
}

#[test]
fn try_from_partial_fails_when_required_field_missing() {
    let partial_missing_a = FooPartial {
        a: None,
        b: Some("hello".into()),
        c: Some(vec![1, 2, 3]),
    };

    let err = Foo::try_from(partial_missing_a).expect_err("conversion must fail");

    // Error type and variant name are generated by the macro:
    // - Error type: FooPartialError
    // - Variant for `a`: AMissing
    let typed: FooPartialError = err;
    match typed {
        FooPartialError::AMissing => {}
        other => panic!("unexpected error variant: {:?}", other),
    }

    let partial_missing_c = FooPartial {
        a: Some(1),
        b: Some("hello".into()),
        c: None,
    };

    let err2 = Foo::try_from(partial_missing_c).expect_err("conversion must fail");
    let _typed2: FooPartialError = err2;
    match _typed2 {
        FooPartialError::CMissing => {}
        other => panic!("unexpected error variant: {:?}", other),
    }
}

#[test]
fn try_from_partial_allows_missing_original_option_fields() {
    // `b` is Option<String> in Foo, so it may be None in FooPartial without error.
    let partial = FooPartial {
        a: Some(5),
        b: None,
        c: Some(vec![9]),
    };

    let foo = Foo::try_from(partial).expect("conversion should succeed");

    assert_eq!(
        foo,
        Foo {
            a: 5,
            b: None,
            c: vec![9],
        }
    );
}
